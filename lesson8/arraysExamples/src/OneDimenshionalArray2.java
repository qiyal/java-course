/**
 * Данная программа демонстрирует основные алгоритмы,
 * которые могут понадобиться при работе с одномерными (и не только) массивами.
 */

import java.util.Scanner;

public class OneDimenshionalArray2 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        //Создаем и заполняем с клавитуры тестовый массив.
        System.out.print("Введите размер Вашего массива: ");
        int aSize = input.nextInt();
        int[] a = new int[aSize];

        System.out.println("Введите с клавиатуры " + aSize + " целых чисел: ");
        for (int i = 0; i < aSize; i++)
            a[i] = input.nextInt();

		/*
		 * 1-ый алгоритм. Нахождение максимального/минимального элемента массива.
		 *
		 * Для этого создаём отдельные переменные, которые будут представлять собой
		 * масимальные/минимальный элемент массива.
		 *
		 * Предположим они называются maxElem и minElem соответственно.
		 *
		 * В обоих случаях приравниваем их к САМОМУ ПЕРВОМУ ЭЛЕМЕНТА МАССИВА.
		 *
		 * Далее проходимся по массиву.
		 *
		 * Сравниваем данные переменные с каждым элементом массива.
		 *
		 * При нахождении элемента БОЛЬШЕ нынешнего значение maxElem,
		 * maxELem становится этим элементом.
		 *
		 * При нахождении элемента МЕНЬШЕ нынешнего значение minElem,
		 * minELem становится этим элементом.
		 *
		 * В конце алгоритма переменна maxElem содержит максимальный элемент массива.
		 * Переменная minElem содержит минимальный элемент массива.
		 */

        // Создаём отдельные переменные для максимального/минимального элементов.
        // И приравниваем их к САМОМУ ПЕРВОМУ ЭЛЕМЕНТУ МАССИВА.
        int maxElem = a[0];
        int minElem = a[0];

        // Начинаем проходиться по массиву.
        for (int currentElem : a) {
            // Сравниваем данные переменные с каждым элементом массива.
            // При нахождении элемента БОЛЬШЕ нынешнего значение maxElem,
            if (currentElem > maxElem) {
                //maxELem становится этим элементом.
                maxElem = currentElem;
            }
            //При нахождении элемента МЕНЬШЕ нынешнего значение minElem,
            if (currentElem < minElem) {
                //minELem становится этим элементом.
                minElem = currentElem;
            }
        }

        System.out.println("\nМаксимальный элемент массива: " + maxElem);
        System.out.println("Минимальный элемент массива: " + minElem);

		/*
		 * 2-ой алгоритм. Нахождение индекса максимального/минимального элементов массива.
		 * Данный алгоритм включает в себя предыдущий.
		 *
		 * Но есть пара дополнений.
		 *
		 * Надо создать отдельные переменные, которые будут представлять собой
		 * ИНДЕКСЫ максимального/минмального элементов массива.
		 *
		 * Приравниваем их К 0.
		 *
		 * Далее выполняем те же операции, что и в предыдущем алгоритмя, НО
		 * запоминаем НЕ ТОЛЬКО максимальные и минимальные элементы, НО И
		 * их ИНДЕКСЫ.
		 *
		 * Смотрим пример ниже.
		 */

        // Создаём отдельные переменные для максимального/минимального элементов.
        // И приравниваем их к САМОМУ ПЕРВОМУ ЭЛЕМЕНТУ МАССИВА.
        int maxElem1 = a[0];
        int minElem1 = a[0];
        // Создаём отдельные переменные для ИНДЕКСОВ максимального/ минимального элементов.
        // И приравниваем их к 0.
        int maxIndex = 0;
        int minIndex = 0;

        // Начинаем проходиться по массиву.
        for (int i = 0; i < aSize; i++) {
            // Сравниваем данные переменные с каждым элементом массива.
            // При нахождении элемента БОЛЬШЕ нынешнего значение maxElem,
            if (a[i] > maxElem1) {
                //maxELem становится этим элементом.
                maxElem1 = a[i];
                //maxIndex становится его индексом.
                maxIndex = i;
            }
            //При нахождении элемента МЕНЬШЕ нынешнего значение minElem,
            if (a[i] < minElem1) {
                //minELem становится этим элементом.
                minElem1 = a[i];
                //minIndex становится его индексом.
                minIndex = i;
            }
        }

        System.out.println("\nИндекс максимального элемента массива: " + maxIndex);
        System.out.println("Индекс минимального элемента массива : " + minIndex);

		/*
		 * 3-ий алгоритм. Нахождение суммы и произведения всех элементов массива.
		 * Для этого создаём отдельные переменные для суммы и для произведения.
		 *
		 * Предположим, что они называются sum и prod соответственно.
		 *
		 * Переменную, отвечающую за сумму ОБЯЗАТЕЛЬНО приравниваем к 0.
		 * Переменную, отвечающую за произведение ОБЯЗАТЕЛЬНО приравниваем к 1.
		 *
		 * Далее проходимся по всему массиву и суммируем все элементы в переменную sum.
		 * И перемножаем все элементы в переменную prod.
		 */

        // Создаём отдельные переменные для суммы и произведения.
        // Приравниваем первую к 0, вторую к 1.
        int sum = 0;
        int prod = 1;

        // Проходимся по массиву
		// 1 2 3 4 5 6 7 8 9 10 ---- value
		// 0 1 2 3 4 5 6 7 8 9 ----- index

		//iter = 1, 2, 3
		// sum = 0(sum) + 1(iter) = 1(sum) + 2(iter) = 3 + 3 = 6 + 4 = 10 + 5 = 15 + 6 = 21 + 7 = 28 + 8 = 36 + 9 = 45 + 10 = 55
        for (int iter : a) {
            // Суммируем все элементы в переменную sum.
            sum = sum + iter;
            // Перемножаем все элементы в переменную prod.
            prod = prod * iter;
        }

        System.out.println("\nСумма всех элементов массива: " + sum);
        System.out.println("Произведение всех элементов массива: " + prod + "\n");

		/*
		 * 4-ий алгоритм. Алгоритм последовательного заполнения массива.
		 *
		 * Необходим тогда, когда неизвестно заранее, сколько элементов будет введено.
		 *
		 * Наприме задача, в которой требуется вводить числа и сохранять их в массиве
		 * до тех пор, ПОКА пользователь не введёт, например, 0.
		 *
		 * Т.Е. Заранее неизвестно, СКОЛЬКО чисел введёт пользователь до тех пор, пока
		 * встретится 0.
		 *
		 * Поэтому цикл for сдесь не подходит, ибо ему нужны чёткие границы. Начало и конец.
		 * Т.е. чёткое число проходов.
		 *
		 * Поэтому будет использоваться цикл while.
		 */

        // Создаём массив, размер которого задаётся с запасом, например 100.
        int[] arr = new int[1000];

		/*
		 * Создаём переменную, которая будет отвечать за последовательное
		 * следование по индексам массива.
		 * То есть первый элемент будет помещён на 0-ой индекс, второй - на 1-ый,
		 * 3-ий - на 2-ой и т.д.
		 */
        int index = 0;

        // Запускаем цикл который будет считывать у пользователя переменную и
        // закидывать её на очередной индекс массива.
        // Также цикл на каждом шаге проверяет, что если очередной пользовательский ввод
        // оказался равен 0, то цикл прерывается и этот 0 НЕ закидывается в массив.

        System.out.println("\nВводите целые числа, сколько хотите.");
        System.out.println("Введите 0, чтобы прекатить ввод. После чего нажмите Enter.");
        int userInput;
        while (true) {
            userInput = input.nextInt();
            if (userInput == 0)
                break;
            arr[index++] = userInput;
        }

		/*
		 * После завершения этого цикла, переменная index как раз равна
		 * количеству элементов, сохранённых в массив.
		 *
		 * Использовать arr.length в данном случае не корректно, так как
		 * она вернёт 100 (фактический размер массива.
		 *
		 * Но пользователь может ввести не 100 элементов, а, например, 12.
		 * В таком случае, если пройтись по всему массиву, то он выдаст
		 * 12 элементов, которые ввёл пользователь и 88 нулей.
		 *
		 * Именно поэтому нам нужна переменная index.
		 *
		 * Например пользователь ввёл 7-ым элементом число "59".
		 * Алгоритм засунул 59 в ячейку под номером 6 (потому что индексация начинается с 0).
		 * И после этого сработал инкремент (++), и переменная index стала равно 7.
		 *
		 * После этого он вводит 0, цикл завершается и мы имеем на руках переменную index,
		 * которая как раз таки равна количеству элементов, которые хранятся на данный момент в массиве.
		 */

        // Выводим те числа, что сохранились в массиве.
        System.out.println("\nВ массиве сейчас хранятся следующие элементы:");
        for (int i = 0; i < index; i++)
            System.out.print(arr[i] + " ");
    }
}
